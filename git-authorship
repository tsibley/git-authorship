#!/bin/bash
set -e -o pipefail

main() {
    # Pull the first revision out of the args, if any.  Default to HEAD.
    local revision="$(git rev-parse --revs-only "$@" | head -n1)"
    : "${revision:=HEAD}"

    # Pull flags out of the args, if any.
    local blame_opts="$(git rev-parse --no-revs --flags "$@")"

    # Remove any revisions and flags from the front of args.  What remains
    # should be files.
    eval "set -- $(git rev-parse --sq --no-revs --no-flags "$@")"

    list-files "$@" | annotate | summarize
}

list-files() {
    git ls-tree -r --name-only -z "$revision" -- "$@"
}

annotate() {
    # I was somewhat surprised to find that a simple read loop is much faster
    # than using GNU Parallel with line buffering (which we need).  This was
    # reliably demonstrated on the Viroverse repository (over 220k lines) on my
    # personal laptop, which has 4 cores, 8GB RAM, and an SSD.  It makes for
    # less deps too, which is nice as GNU Parallel can sometimes be hard to
    # come by with distro packages.

    while read -r -d $'\0' fname; do
        git blame -CCC -M --line-porcelain $blame_opts "$revision" -- "$fname"
    done
}

summarize() {
    perl -MList::Util=max,sum -ne '
        next unless s/^author //;
        chomp;

        $authors{ $_ }++;

        END {
            my $length = 1 + max map { length } values %authors;
            my $total  = sum values %authors;

            printf "%*d  %3.0f%%  %s\n", $length, $authors{$_}, $authors{$_} / $total * 100, $_
                for sort { $authors{$b} <=> $authors{$a} }
                    keys %authors;
        }
    '
}

main "$@"
